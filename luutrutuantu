// File: SequentialTree.cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int MAX_SIZE = 100;

class SequentialTree {
private:
    vector<char> tree; // Mảng lưu trữ các nút
    int capacity;

public:
    // Khởi tạo cây
    SequentialTree(int maxSize = MAX_SIZE) {
        capacity = maxSize;
        tree.resize(capacity, '\0'); // Khởi tạo tất cả là ký tự rỗng
    }

    // Kiểm tra cây rỗng
    bool isEmpty() {
        return tree[1] == '\0'; // Nếu gốc (vị trí 1) rỗng
    }

    // Thêm nút gốc
    void setRoot(char value) {
        if (tree[1] == '\0') {
            tree[1] = value;
        } else {
            cout << "Root already exists!\n";
        }
    }

    // Thêm con trái
    void addLeftChild(int parentIndex, char value) {
        int leftIndex = 2 * parentIndex;
        if (leftIndex >= capacity) {
            cout << "Index out of bounds!\n";
            return;
        }
        if (tree[leftIndex] == '\0') {
            tree[leftIndex] = value;
        } else {
            cout << "Left child already exists!\n";
        }
    }

    // Thêm con phải
    void addRightChild(int parentIndex, char value) {
        int rightIndex = 2 * parentIndex + 1;
        if (rightIndex >= capacity) {
            cout << "Index out of bounds!\n";
            return;
        }
        if (tree[rightIndex] == '\0') {
            tree[rightIndex] = value;
        } else {
            cout << "Right child already exists!\n";
        }
    }

    // Duyệt tiền thứ tự (Preorder)
    void preorder(int index = 1) {
        if (index >= capacity || tree[index] == '\0') return;
        cout << tree[index] << " ";
        preorder(2 * index);
        preorder(2 * index + 1);
    }

    // Duyệt trung thứ tự (Inorder)
    void inorder(int index = 1) {
        if (index >= capacity || tree[index] == '\0') return;
        inorder(2 * index);
        cout << tree[index] << " ";
        inorder(2 * index + 1);
    }

    // Duyệt hậu thứ tự (Postorder)
    void postorder(int index = 1) {
        if (index >= capacity || tree[index] == '\0') return;
        postorder(2 * index);
        postorder(2 * index + 1);
        cout << tree[index] << " ";
    }

    // Hiển thị cây
    void display() {
        for (int i = 1; i < capacity; i++) {
            if (tree[i] != '\0')
                cout << "Index " << i << ": " << tree[i] << endl;
        }
    }
};

int main() {
    SequentialTree tree(20);

    // Tạo cây mẫu
    tree.setRoot('A');
    tree.addLeftChild(1, 'B');
    tree.addRightChild(1, 'C');
    tree.addLeftChild(2, 'D');
    tree.addRightChild(2, 'E');
    tree.addLeftChild(3, 'F');

    cout << "Sequential Tree Storage:\n";
    cout << "Tree nodes:\n";
    tree.display();

    cout << "\nPreorder traversal: ";
    tree.preorder();
    cout << "\nInorder traversal: ";
    tree.inorder();
    cout << "\nPostorder traversal: ";
    tree.postorder();
    cout << endl;

    return 0;
}


