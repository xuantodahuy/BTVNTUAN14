// File: LinkedTree.cpp
#include <iostream>
#include <queue>
using namespace std;

struct TreeNode {
    char data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(char val) : data(val), left(nullptr), right(nullptr) {}
};

class LinkedTree {
private:
    TreeNode* root;

public:
    // Khởi tạo cây rỗng
    LinkedTree() : root(nullptr) {}

    // Kiểm tra cây rỗng
    bool isEmpty() {
        return root == nullptr;
    }

    // Tạo nút gốc
    void setRoot(char value) {
        if (root == nullptr) {
            root = new TreeNode(value);
        } else {
            cout << "Root already exists!\n";
        }
    }

    // Thêm con trái cho nút cha (tìm theo giá trị)
    void addLeftChild(char parentValue, char value) {
        TreeNode* parent = findNode(root, parentValue);
        if (parent == nullptr) {
            cout << "Parent not found!\n";
            return;
        }
        if (parent->left == nullptr) {
            parent->left = new TreeNode(value);
        } else {
            cout << "Left child already exists!\n";
        }
    }

    // Thêm con phải cho nút cha (tìm theo giá trị)
    void addRightChild(char parentValue, char value) {
        TreeNode* parent = findNode(root, parentValue);
        if (parent == nullptr) {
            cout << "Parent not found!\n";
            return;
        }
        if (parent->right == nullptr) {
            parent->right = new TreeNode(value);
        } else {
            cout << "Right child already exists!\n";
        }
    }

    // Hàm tìm nút theo giá trị (BFS)
    TreeNode* findNode(TreeNode* start, char value) {
        if (start == nullptr) return nullptr;
        queue<TreeNode*> q;
        q.push(start);
        while (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();
            if (current->data == value) return current;
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
        return nullptr;
    }

    // Duyệt tiền thứ tự
    void preorder(TreeNode* node) {
        if (node == nullptr) return;
        cout << node->data << " ";
        preorder(node->left);
        preorder(node->right);
    }

    // Duyệt trung thứ tự
    void inorder(TreeNode* node) {
        if (node == nullptr) return;
        inorder(node->left);
        cout << node->data << " ";
        inorder(node->right);
    }

    // Duyệt hậu thứ tự
    void postorder(TreeNode* node) {
        if (node == nullptr) return;
        postorder(node->left);
        postorder(node->right);
        cout << node->data << " ";
    }

    // Gọi duyệt từ gốc
    void preorder() { preorder(root); }
    void inorder() { inorder(root); }
    void postorder() { postorder(root); }

    // Hiển thị cây theo BFS
    void display() {
        if (root == nullptr) return;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();
            cout << current->data << " ";
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
        cout << endl;
    }
};

int main() {
    LinkedTree tree;

    // Tạo cây mẫu
    tree.setRoot('A');
    tree.addLeftChild('A', 'B');
    tree.addRightChild('A', 'C');
    tree.addLeftChild('B', 'D');
    tree.addRightChild('B', 'E');
    tree.addLeftChild('C', 'F');

    cout << "Linked Tree Storage:\n";
    cout << "BFS traversal: ";
    tree.display();

    cout << "Preorder traversal: ";
    tree.preorder();
    cout << "\nInorder traversal: ";
    tree.inorder();
    cout << "\nPostorder traversal: ";
    tree.postorder();
    cout << endl;

    return 0;
}
